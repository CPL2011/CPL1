TODO's
____________

SCALA: 
- class Graph, Node, Edge: functionality = (add Node, remove Node, add Edge, remove Edge, get Neighbours, 
(undirected edges are represented using two directed edges), get all Nodes, 
traversing the graph: Breadth-first, Depth-first)
- Node, Edge and Graph will use a 'visualization' trait to provide the Ubigraph functionality
- visualization needs some init , refresh functionality
if you call visualization multiple times. You get duplicates in ubigraph. But there should be a way to add and visualize new Nodes/Edges during simulation. I created some temporary methods in the example.fluspread but this is clearly not enough.
- Simulation Engine: ...?
- I think the library must give the user some help(errors) to setup his custom Node. Some suggestions:

* Create RoundGraph trait and add the entire graph to the engine. Trait will provide one of the functions below

RoundGraph.getRoundClients():List[RoundClient]
constructor RoundEngine(RoundGraph)

or
RoundGraph.doRound(timestamp:Int,duration:Int)
this for each engineType of course.

* Make Node abstract and create abstract method for doRound doTurn...
In this case user must create all abstract functions but he desides wich he implements.

Graph has no list of Edges...
But he needs them in the visualize method,
so we hack the liberary to get a list of edges.
What was the reason that Graph Shouldn't have a list of Edges?

XML: 
- loading and storing...db4o? GraphML GEXP? get feedback

INSTALL UBIGRAPH:
http://ubietylab.net/ubigraph/content/Docs/index.html#languagebindings (Java)
(install apache-xmlrpc-3.1.3 and UbiGraph-alpa-0.2.4-Linux32-Debian-4)


BUGS
_____________
* There is no way I can define myEdge extends Edge and add use this edge to connect two Nodes with each other.
* With the new version of the graph I still need to overide the graph as I need the ubigraphClient variable to for the update function to work...

Graph.visualize(UpdateVisualization) -> I find this kind of weard...
where to visualize? How should I use this function..? 
What if I want to change the initial visualization??

Suggestion::::
Perhaps provide dummy methods that the user can override. The methods will have basic functionality so by using super this functionality can be extended by the user. Method calls will be automaticaly by the framework and a parameter ubigraph will be delivered.

Pseudocode framework
- Node.initVisualization(ubigraphClient) {addNodeToUbigraph}
- Node.visualize(ubigraphClient) {
	//Perhaps to some automatic updateing to the node.
	//Ex: If Node.color is added to library updates of colors can 	  be done here
}


Pseudocode myNode extends Node
override def myNode.initVisualization(ubi){
	//super.initVisualization(ubi)
	set some extra parameters on the new object.
	Perhaps the size of the structure.
}

override def myNode.visualize(ubi){
	super.visualize(ubi)
	//Add some custom visualization
}


- I need to update ubigraphClient for my server to work all right. So if you make ubigraphclient a val I can't visualize. Perhaps make two constructors of VisualizableGraph. One with the serverString and one Witout...

IN PROGRESS
_____________
- the db4o storage still does not work properly and I probably do not have the time today/tomorrow to fix it... 
The problem is that db4o does not store the references that are stored in the graph object. I tried the config
method, but it did not work.
- Simulation Engine and TurnBasedEngine started (Jordi)
- Continued coding Flu Spreading from Node.infection



DONE
_____________
- Most basic functionality has been provided but things might still have to be refactored into different classes/traits 
(for 'traversing' check the ideas below, for visualizing the graph, a more robust strategy might be neat)
- trait 'infectable'
- Because of the problems with the object databases that I had(I'm sure that I probably made some stupid
mistakes), I have implemented a load/store mechanism based on xml. It is a bit more code that with db4o,
but at least it works:) Just do "graph.save(path)" to save it, and to load from a file use "graph2.loadGraph(path)"
- Fixed db4o store



IDEAS
_____________
I kind of don't like how the neighbours/nodes are managed in our graph. Now we keep the neighbour nodes in each node 
and we keep the edges(that also contain nodes) in the graph. This is double the work. I would only keep edges to neighbours in the 
Node, so the graph only has a map of nodes. However it could be that the way it is now implemented was done for
a specific reason, so then you can ignore this...

Splitting the code into different files was an excellent decision. It had to happen sooner or later.

We can use an itterator pattern to implement different traversing strategy's.
---> Yea, we'll have to choose whether to implement using scala library traits Iterator or Traversable. 
---> I believe the assignment is hinting towards the use of Traversable. Adapting the code should be easy,
---> creating a wrapper class extending the trait and copying the foreach (currently called traverse) implementation.

For those like me already having an eclipse on there windows pc.
You can run an Ubigraph App in your familiar environment while outputting to the Linux Ubigraph Server.
The only thing you have to change is adding some libraries and:
UbigraphClient graph = new UbigraphClient("http://<LinuxUbigraphServer>:20738/RPC2");
It's working great so far :p